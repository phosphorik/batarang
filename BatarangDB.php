<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');

class BatarangDB {
    var $BatarangConfig;
    var $Batarang;
    function __construct($ConfigReference, $Batarang){
        $this->BatarangConfig   = $ConfigReference;
        $this->Batarang         = $Batarang;
    }
    
    public function escape_string($data){
        switch ($this->BatarangConfig->DBDriver){
            case 'PostgreSQL':
                return pg_escape_string($data);
                break;
            case 'MSSQL':
                if(is_numeric($data))
				return $data;
                $unpacked = unpack('H*hex', $data);
                return '0x' . $unpacked['hex'];
                break;
            case 'MySQL':
            	return mysql_escape_string($data);
            	break;
        }
        return false;
    }
    
    function mssql_qf($query){
	$query = mssql_query($query) or die();
	
	if (is_resource($query)){
		return mssql_fetch_all($query);
	} else {
		return false;
	}
	
    }
    
    public function mssql_fetch_all($resource){
            $i = 0;
            $out = array();
            while ( $record = mssql_fetch_array($resource, MSSQL_ASSOC) )
            {					
                    $keys = array_keys($record);
                    foreach($keys as $key){
                            $out[$i][$key] = $record[$key];
                    }
                    $i++;
            }
            return $out; 
    }
    
    public function mysql_fetch_all($result) {
		$all = array();
		while ($all[] = mysql_fetch_assoc($result)) {}
		return $all;
	}
    
    public function GetEditValues($ActionList, $Action){
	$i = 0;
	
	// Right now this just pulls the first table out of the list, which
	// is really fragile - ideally we need to disable automatic generation
	// on queries that involve multiple tables. I don't think it's even
	// possible to autodetect that except when each table's fieldnames are
	// COMPLETELY unique, and even when that's the case implementing this
	// would make the app break if that ever changed.
	$Table = array_keys($ActionList['ByName']);
	$Column = $ActionList['ByName'][$Table[0]];
	$Query = "SELECT * FROM {$Column} WHERE ";
	foreach (array_keys($ActionList['ByKey']) as $Key){
		if ($i) {$Query .= " AND ";}
		$s_Where = $this->escape_string($_POST[$Action['FieldPrefix'].'field_'.$i]);
		$Query .= "{$Key} = '{$s_Where}'";
		$i++;
	}
	$r = pg_query($Query); $r = pg_fetch_all($r);
	
	return $r[0];
    }
    
    public function ArrayQuery($Query){
    	$Data = $this->Query($Query);
    	
    	switch ($this->BatarangConfig->DBDriver){
            case 'PostgreSQL':
            	$Response = pg_fetch_all($Data);
                break;
            case 'MSSQL':
          		$Response = mssql_fetch_all($Data);
                break;
            case 'MySQL':
            	$Response = mysql_fetch_all($Data);
            	break;
        }
        
        return($Response);
    }
    
    public function Query($query){
    	switch ($this->BatarangConfig->DBDriver){
            case 'PostgreSQL':
            	$Response = pg_query($query);
                break;
            case 'MSSQL':
          		$Response = mssql_query($query);
                break;
            case 'MySQL':
            	$Response = mysql_query($query);
            	break;
        }
    	return $Response;    
    }
    
    public function ActionQuery($ActionQuery){
            echo($ActionQuery); //debug
            $this->Query($ActionQuery);
            // this is a very bad hack: in order to keep the batarang library completely modular
            // and autodetect the form/query details without prior config, we have to perform
            // the hook/query here... in the view. Which is evil, obviously. But the alternative
            // is to add another layer of configs, and sacrifice anonymous, autogenerated
            // forms. The quick and dirty solution is simply to stop execution and reload the
            // current page.
            header('Location: '.current_url());
            die;
    }
    
    public function BuildActionQuery($Action, $Type = 'add', $Fields = false){
        // This is built off an array in the Batarang call that defines
        // which field elements are required to add records. This
        // could be generated automatically with the help of a
        // DESCRIBE query but making that a reasonable solution would
        // involve a more intelligent caching solution than I'm capable
        // of right now to avoid doubling the queries needed per Batarang
        // call.
        switch ($this->BatarangConfig->DBDriver){
            case 'MSSQL': // In this case the MS-SQL query should be identical to the PostgreSQL query
            case 'PostgreSQL':
                if (strtolower($Type) == 'add'){
                        foreach($Action['Table'] as $Column => $FieldProps){
                                $FieldsToInsert = Array();
                                $ActionQuery = "INSERT INTO \n";
                                $Keys = array_keys($FieldProps);
                                $ActionQueryTables[] = $Column;
                                
                                foreach($Keys as $Field){
                                        $FieldsToInsert[] = $Field;
                                        
                                        // The following needs to be substantially rewritten
                                        // for interop with non-Postgres systems 
                                        $DataToInsert[] = "'".@$this->escape_string($_REQUEST[$Action['FieldPrefix'].$Field])."'"; 
                                        //echo($Action['FieldPrefix'].$Field.'<br><br>'); print_r($_REQUEST); die;
                                        $UIFieldsProperties[$Field] = $this->Batarang->GetFieldProps($FieldProps[$Field]);
                                        
                                        // Check to see if any built-in actions (like deleting/editing onscreen
                                        // records) are enabled on this Batarang form
                                        if (in_array(
                                                $this->Batarang->__BuiltInActions,
                                                $UIFieldsProperties[$Field]
                                        )){
                                                foreach ($UIFieldsProperties[$Field] as $Key => $Value) {
                                                        if (!in_array($Key,$this->Batarang->__BuiltInActions)) { continue; }
                                                        $BuiltInAction[$Field][$Key] = $Value;
                                                        $BuiltInActionsList[$Key] = true; 
                                                }
                                        
                                                
                                        }
                                        
                                }
                                
                                
                                //print_r($DataToInsert);die;
                                $UIFields			= $FieldsToInsert;
                                $FieldsToInsert		= implode(', ', $FieldsToInsert);
                                $DataToInsert		= implode(', ', $DataToInsert);
                                $ActionQueryTables	= implode(', ', $ActionQueryTables);
                                $ActionQuery = $ActionQuery." ".$ActionQueryTables."\n ($FieldsToInsert)\n VALUES ($DataToInsert);";
                                
                        }
                        
                        $return = array(
                                "UIFields"				=>	$UIFields,
                                "UIFieldsProperties"	=>	$UIFieldsProperties,
                                "ActionQuery"			=>	$ActionQuery
                        );
                        
                } else if (strtolower($Type) == 'delete'){
		    // This can cause problems if the Batarang instance involves a
                   // multi-table Delete that has identical field names which
                   // are identical to one used to build the Delete query.
                   //
                   // I don't know if this can be done more intelligently, but
                   // what I am more sure of is that there's no way to get the
                   // information necessary to build a better query without
                   // requiring more setup from whoever implements Batarang. Read:
                   // it's possible, but it breaks with the whole minimal-conf
                   // thing and at that point they should be using custom actions
                   // anyway.
                        $ActionList = $this->Batarang->BuildActionList($Action);
                        $ActionQuery = '';
			//$Action['FieldPrefix']."field_".{$i}
                        foreach (array_unique($ActionList['ByName']) as $Table){ 
                                $ActionQuery .= "DELETE from {$Table}
                                WHERE\n";
                                if (sizeOf($ActionList['ByName']) > 0){
					$i = 0;
                                        foreach (array_keys($ActionList['ByKey']) as $WhereField) {
						if ($i) { $ActionQuery .= ' AND '; }
                                                $WhereEquals = $this->escape_string($_POST[$Action['FieldPrefix']."field_".$i]);
                                                $WhereField = $this->escape_string($WhereField);
                                                $ActionQuery .= "{$WhereField}='{$WhereEquals}'";
						$i++;
                                        }
                                }
                        }
                $return = array("ActionQuery"	=>	$ActionQuery);
		
                } else if (strtolower($Type) == 'edit') {
		    $ActionList = $this->Batarang->BuildActionList($Action);
		    $Sets = array();
		    $Table = array_values($ActionList['ByName']);
		    $Column = $Table[0];
		    //print_r($ActionList);die;
		    
		    $ActionQuery = "UPDATE $Column\n SET ";
		    
		    foreach ($Fields as $Field){
			if (!isset($_REQUEST[$Action['FieldPrefix'].$Field])){continue;}
			$s_Field = $this->escape_string($_REQUEST[$Action['FieldPrefix'].$Field]);
			$Sets[] .= "$Field = '".$s_Field."'";
		    }
		    
		    $ActionQuery .= implode(', ', $Sets) . ' WHERE ';
		    
		    $i = 0;
		    foreach (array_keys($ActionList['ByKey']) as $WhereField) {
			    if ($i) { $ActionQuery .= ' AND '; }
			    $WhereEquals = $this->escape_string($_REQUEST[$Action['FieldPrefix'].'current_'.$WhereField]);
			    $WhereField = $this->escape_string($WhereField);
			    $ActionQuery .= "{$WhereField}='{$WhereEquals}'";
			    $i++;
		    }
		    
		    $ActionQuery .= ';';
		    
		    $return = array("ActionQuery"	=>	$ActionQuery);
		}
		
            break;
        }
	return $return;
    }
}
